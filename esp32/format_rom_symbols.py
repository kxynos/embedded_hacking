#!/usr/bin/env python3
"""
Format ESP32 ROM linker script symbols for Ghidra's SymbolImportScript.

Features:
- Recursively process multiple input paths (files or directories).
- Parses common ld lines like: `PROVIDE ( ets_printf = 0x40000010 );`
  and `ets_printf = 0x40000010;`
- Excludes lines that do not contain a 0x... address.
- Outputs `"<symbol> <address> l"` entries.
- Can write one consolidated output file or per-file outputs (default).

Usage examples:
    python format_rom_symbols.py path/to/rom/ld/ dir/another_roms/
    python format_rom_symbols.py input.ld --out all_symbols.txt

Copyleft 2025 - Generated by GenAI.
Idea from : https://gist.github.com/jmswrnr/3095b39f8b1f3631489a5db75a275875/5a2c3a0b21ddf8db658c412975b98c192e3ac3bf
"""
import argparse
import os
import re
from pathlib import Path
from typing import Iterable, List, Tuple

# Regex: optional PROVIDE( ... ), capture name and a hex address starting with 0x
LINE_RE = re.compile(r"""
    ^\s*
    (?:PROVIDE\s*\(\s*)?    # optional PROVIDE(
    ([^\s=]+)                 # symbol name (group 1)
    \s*[=:]?\s*               # optional = or : and spaces
    (0x[0-9a-fA-F]+)           # hex address starting with 0x (group 2)
""", re.VERBOSE)

COMMENT_RE = re.compile(r"^\s*(/\*|//|#)")


def parse_ld_lines(lines: Iterable[str]) -> List[Tuple[str, str]]:
    """Return list of (symbol, address) pairs from ld-like lines.
    Excludes any line without a 0x-address.
    """
    results: List[Tuple[str, str]] = []
    for line in lines:
        # Skip empty or comment lines
        if not line.strip():
            continue
        if COMMENT_RE.match(line):
            continue
        m = LINE_RE.search(line)
        if m:
            sym = m.group(1)
            addr = m.group(2)
            # Basic sanity: symbol shouldn't contain parentheses or semicolons
            if sym and addr.startswith("0x"):
                results.append((sym, addr))
    return results


def process_file(path: Path) -> List[str]:
    """Process a single file and return formatted lines for Ghidra.
    Each line: "<symbol> <address> l"
    """
    try:
        with path.open("r", encoding="utf-8", errors="ignore") as f:
            pairs = parse_ld_lines(f)
        return [f"{sym} {addr} l" for sym, addr in pairs]
    except Exception as e:
        return [f"# ERROR reading {path}: {e}"]


def find_input_files(paths: List[Path], exts=(".ld", ".lds", ".txt")) -> List[Path]:
    """Collect files from provided paths. If a path is a directory, recurse.
    Filters by extension list by default.
    """
    files: List[Path] = []
    for p in paths:
        if p.is_file():
            if exts and p.suffix.lower() not in exts:
                # include anyway if ext filter not strict? We'll include only listed.
                continue
            files.append(p)
        elif p.is_dir():
            for root, _, filenames in os.walk(p):
                for name in filenames:
                    fp = Path(root) / name
                    if exts and fp.suffix.lower() not in exts:
                        continue
                    files.append(fp)
        else:
            # not found; ignore
            pass
    return sorted(files)


def write_output_per_file(files: List[Path], lines_map: dict, suffix: str = ".ghidra.txt") -> None:
    for f in files:
        lines = lines_map.get(f, [])
        out_path = f.with_suffix(f.suffix + suffix)
        with out_path.open("w", encoding="utf-8") as out:
            out.write("\n".join(lines) + "\n")
        print(f"Wrote {out_path} ({len(lines)} symbols)")


def write_output_consolidated(files: List[Path], lines_map: dict, out_path: Path) -> None:
    with out_path.open("w", encoding="utf-8") as out:
        for f in files:
            lines = lines_map.get(f, [])
            if not lines:
                continue
            #out.write(f"# From {f}\n")
            out.write("\n".join(lines) + "\n")
    print(f"Wrote consolidated output to {out_path}")


def main():
    ap = argparse.ArgumentParser(description="Format ESP32 ROM ld symbols for Ghidra SymbolImportScript")
    ap.add_argument("paths", nargs="+", help="Input .ld files or directories to process recursively")
    ap.add_argument("--out", dest="out", help="Write all results to a single output file (consolidated)")
    ap.add_argument("--ext", dest="ext", nargs="*", default=[".ld", ".lds", ".txt"],
                    help="File extensions to include (default: .ld .lds .txt)")
    args = ap.parse_args()

    in_paths = [Path(p) for p in args.paths]
    files = find_input_files(in_paths, exts=tuple(s.lower() if s.startswith(".") else f".{s.lower()}" for s in args.ext))

    if not files:
        print("No input files found.")
        return

    lines_map = {}
    for f in files:
        lines_map[f] = process_file(f)

    if args.out:
        write_output_consolidated(files, lines_map, Path(args.out))
    else:
        write_output_per_file(files, lines_map)

if __name__ == "__main__":
    main()
